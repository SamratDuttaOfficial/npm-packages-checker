#include "vulnerability_checker.h"
#include <ctype.h>

// Remove problematic defines for now

// Safe case-insensitive string comparison
static int safe_strcasecmp(const char *s1, const char *s2) {
    if (!s1 || !s2) return (s1 == s2) ? 0 : 1;

    while (*s1 && *s2) {
        char c1 = tolower((unsigned char)*s1);
        char c2 = tolower((unsigned char)*s2);
        if (c1 != c2) return c1 - c2;
        s1++;
        s2++;
    }
    return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);
}

// Custom case-insensitive substring search for compatibility
static char* case_insensitive_strstr(const char *haystack, const char *needle) {
    if (!haystack || !needle) return NULL;

    size_t needle_len = strlen(needle);
    if (needle_len == 0) return (char*)haystack;

    for (const char *p = haystack; *p; p++) {
        // Use our own comparison instead of strncasecmp
        int match = 1;
        for (size_t i = 0; i < needle_len; i++) {
            if (!p[i] || tolower((unsigned char)p[i]) != tolower((unsigned char)needle[i])) {
                match = 0;
                break;
            }
        }
        if (match) {
            return (char*)p;
        }
    }
    return NULL;
}

int is_version_vulnerable(const Package *vuln_pkg, const char *used_version) {
    if (vuln_pkg == NULL || used_version == NULL) {
        return 0;
    }

    for (int i = 0; i < vuln_pkg->version_count; i++) {
        if (strcmp(vuln_pkg->versions[i], used_version) == 0) {
            return 1;
        }
    }

    return 0;
}

// Function to extract package name without version
static void extract_package_name(const char *full_name, char *clean_name, size_t clean_size) {
    if (!full_name || !clean_name) return;

    // Copy the full name first
    strncpy(clean_name, full_name, clean_size - 1);
    clean_name[clean_size - 1] = '\0';

    // Remove version part (everything after @, but keep scoped packages like @babel/cli)
    char *at_pos = strchr(clean_name, '@');
    if (at_pos && at_pos != clean_name) { // Don't remove @ at the beginning (scoped packages)
        *at_pos = '\0';
    }

    char temp[MAX_PACKAGE_NAME_LEN];
    if (strncmp(clean_name, "node_modules/", 13) == 0) {
        strcpy(temp, clean_name + 13);
        strcpy(clean_name, temp);
    }
}

int is_partial_match(const char *vuln_name, const char *dep_name) {
    if (vuln_name == NULL || dep_name == NULL) return 0;

    char vuln_clean[MAX_PACKAGE_NAME_LEN];
    char dep_clean[MAX_PACKAGE_NAME_LEN];

    // Extract clean package names
    extract_package_name(vuln_name, vuln_clean, sizeof(vuln_clean));
    extract_package_name(dep_name, dep_clean, sizeof(dep_clean));

    // Check for exact match first (case insensitive)
    if (safe_strcasecmp(vuln_clean, dep_clean) == 0) {
        return 1;
    }

    if (case_insensitive_strstr(vuln_clean, dep_clean) || case_insensitive_strstr(dep_clean, vuln_clean)) {
        return 1;
    }

    const char *vuln_core = strchr(vuln_clean, '/');
    const char *dep_core = strchr(dep_clean, '/');

    if (vuln_core) vuln_core++; else vuln_core = vuln_clean;
    if (dep_core) dep_core++; else dep_core = dep_clean;

    if (case_insensitive_strstr(vuln_core, dep_core) || case_insensitive_strstr(dep_core, vuln_core)) {
        return 1;
    }

    return 0;
}

static void add_vulnerability_match(VulnerabilityResults *results,
                                   const char *package_name,
                                   const char *vulnerable_package_name,
                                   const char *vulnerable_version,
                                   const char *used_version,
                                   const char *dependency_path,
                                   int is_direct,
                                   int match_type) {
    if (results == NULL) return;

    VulnerabilityMatch *match;
    if (match_type == 0 && results->count < MAX_PACKAGES) {
        // Exact match - vulnerability
        match = &results->matches[results->count];
        results->count++;
    } else if (match_type == 1 && results->warning_count < MAX_PACKAGES) {
        // Partial match - warning
        match = &results->warnings[results->warning_count];
        results->warning_count++;
    } else {
        return; // No space
    }

    strncpy(match->package_name, package_name, sizeof(match->package_name) - 1);
    match->package_name[sizeof(match->package_name) - 1] = '\0';

    strncpy(match->vulnerable_package_name, vulnerable_package_name, sizeof(match->vulnerable_package_name) - 1);
    match->vulnerable_package_name[sizeof(match->vulnerable_package_name) - 1] = '\0';

    strncpy(match->vulnerable_version, vulnerable_version, sizeof(match->vulnerable_version) - 1);
    match->vulnerable_version[sizeof(match->vulnerable_version) - 1] = '\0';

    strncpy(match->used_version, used_version, sizeof(match->used_version) - 1);
    match->used_version[sizeof(match->used_version) - 1] = '\0';

    strncpy(match->dependency_path, dependency_path, sizeof(match->dependency_path) - 1);
    match->dependency_path[sizeof(match->dependency_path) - 1] = '\0';

    match->is_direct_dependency = is_direct;
    match->match_type = match_type;
}

int check_vulnerabilities(const PackageList *vulnerable_packages,
                         const DependencyTree *dependencies,
                         VulnerabilityResults *results) {
    if (vulnerable_packages == NULL || dependencies == NULL || results == NULL) {
        return 0;
    }

    results->count = 0;
    results->warning_count = 0;

    // Iterate through each dependency
    for (int dep_idx = 0; dep_idx < dependencies->count; dep_idx++) {
        const DependencyNode *dep = &dependencies->nodes[dep_idx];

        // Check against each vulnerable package
        for (int vuln_idx = 0; vuln_idx < vulnerable_packages->count; vuln_idx++) {
            const Package *vuln_pkg = &vulnerable_packages->packages[vuln_idx];

            // Check for exact package name match (case-sensitive)
            if (strcmp(dep->name, vuln_pkg->name) == 0) {
                // Check if version is vulnerable
                if (is_version_vulnerable(vuln_pkg, dep->version)) {
                    add_vulnerability_match(results, dep->name, vuln_pkg->name,
                                          dep->version, dep->version, dep->path,
                                          dep->is_direct, 0); // 0 = exact match
                }
            }
            // Check for partial matches (case-insensitive)
            else if (is_partial_match(vuln_pkg->name, dep->name)) {
                // Add as warning for partial matches
                add_vulnerability_match(results, dep->name, vuln_pkg->name,
                                      dep->version, dep->version, dep->path,
                                      dep->is_direct, 1); // 1 = partial match warning
            }
        }
    }

    return 1;
}