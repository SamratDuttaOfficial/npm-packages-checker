#include "../test_framework.h"
#include "../../src/vulnerability_checker.h"
#include "../../src/common.h"

int test_is_version_vulnerable_match() {
    Package vuln_pkg = {0};
    strcpy(vuln_pkg.name, "lodash");
    strcpy(vuln_pkg.versions[0], "4.17.19");
    strcpy(vuln_pkg.versions[1], "4.17.20");
    vuln_pkg.version_count = 2;

    int result1 = is_version_vulnerable(&vuln_pkg, "4.17.19");
    TEST_ASSERT_EQ(1, result1, "Should detect vulnerable version 4.17.19");

    int result2 = is_version_vulnerable(&vuln_pkg, "4.17.20");
    TEST_ASSERT_EQ(1, result2, "Should detect vulnerable version 4.17.20");

    return 1;
}

int test_is_version_vulnerable_no_match() {
    Package vuln_pkg = {0};
    strcpy(vuln_pkg.name, "lodash");
    strcpy(vuln_pkg.versions[0], "4.17.19");
    strcpy(vuln_pkg.versions[1], "4.17.20");
    vuln_pkg.version_count = 2;

    int result = is_version_vulnerable(&vuln_pkg, "4.17.21");
    TEST_ASSERT_EQ(0, result, "Should not detect non-vulnerable version");

    return 1;
}

int test_is_version_vulnerable_null_inputs() {
    Package vuln_pkg = {0};
    strcpy(vuln_pkg.name, "lodash");
    strcpy(vuln_pkg.versions[0], "4.17.19");
    vuln_pkg.version_count = 1;

    int result1 = is_version_vulnerable(NULL, "4.17.19");
    TEST_ASSERT_EQ(0, result1, "Should return 0 for NULL package");

    int result2 = is_version_vulnerable(&vuln_pkg, NULL);
    TEST_ASSERT_EQ(0, result2, "Should return 0 for NULL version");

    return 1;
}

int test_check_vulnerabilities_no_matches() {
    // Create vulnerable packages list
    PackageList *vuln_packages = create_package_list();
    TEST_ASSERT(vuln_packages != NULL, "Should create package list");

    // Add a vulnerable package
    Package vuln_pkg;
    memset(&vuln_pkg, 0, sizeof(Package));  // More reliable than = {0}
    strcpy(vuln_pkg.name, "lodash");
    strcpy(vuln_pkg.versions[0], "4.17.19");
    vuln_pkg.version_count = 1;  // Explicitly set this!
    add_package(vuln_packages, &vuln_pkg);

    // Create dependencies tree with non-matching packages
    DependencyTree *dependencies = create_dependency_tree();
    TEST_ASSERT(dependencies != NULL, "Should create dependency tree");

    // Add a dependency that doesn't match
    DependencyNode dep_node;
    memset(&dep_node, 0, sizeof(DependencyNode));  // More reliable initialization
    strcpy(dep_node.name, "express");
    strcpy(dep_node.version, "4.18.0");
    strcpy(dep_node.path, "direct");
    dep_node.is_direct = 1;
    add_dependency(dependencies, &dep_node);

    // Run vulnerability check
    VulnerabilityResults results = {0};
    int success = check_vulnerabilities(vuln_packages, dependencies, &results);

    TEST_ASSERT_EQ(1, success, "Should successfully check vulnerabilities");
    TEST_ASSERT_EQ(0, results.count, "Should find 0 vulnerabilities");

    free_package_list(vuln_packages);
    free_dependency_tree(dependencies);
    return 1;
}

int test_check_vulnerabilities_with_matches() {
    // Create vulnerable packages list
    PackageList *vuln_packages = create_package_list();
    TEST_ASSERT(vuln_packages != NULL, "Should create package list");

    // Add a vulnerable package
    Package vuln_pkg = {0};
    strcpy(vuln_pkg.name, "lodash");
    strcpy(vuln_pkg.versions[0], "4.17.19");
    vuln_pkg.version_count = 1;
    add_package(vuln_packages, &vuln_pkg);

    // Create dependencies tree
    DependencyTree *dependencies = create_dependency_tree();
    TEST_ASSERT(dependencies != NULL, "Should create dependency tree");

    // Add a matching dependency
    DependencyNode dep_node = {0};
    strcpy(dep_node.name, "lodash");
    strcpy(dep_node.version, "4.17.19");
    strcpy(dep_node.path, "node_modules/lodash");
    dep_node.is_direct = 1;
    add_dependency(dependencies, &dep_node);

    // Run vulnerability check
    VulnerabilityResults results = {0};
    int success = check_vulnerabilities(vuln_packages, dependencies, &results);

    TEST_ASSERT_EQ(1, success, "Should successfully check vulnerabilities");
    TEST_ASSERT_EQ(1, results.count, "Should find 1 vulnerability");
    TEST_ASSERT_EQ(0, results.warning_count, "Should find 0 warnings");

    // Verify the vulnerability match details
    VulnerabilityMatch *match = &results.matches[0];
    TEST_ASSERT_STR_EQ("lodash", match->package_name, "Package name should match");
    TEST_ASSERT_STR_EQ("lodash", match->vulnerable_package_name, "Vulnerable package name should match");
    TEST_ASSERT_STR_EQ("4.17.19", match->vulnerable_version, "Vulnerable version should match");
    TEST_ASSERT_STR_EQ("4.17.19", match->used_version, "Used version should match");
    TEST_ASSERT_STR_EQ("node_modules/lodash", match->dependency_path, "Dependency path should match");
    TEST_ASSERT_EQ(1, match->is_direct_dependency, "Should be marked as direct dependency");
    TEST_ASSERT_EQ(0, match->match_type, "Should be exact match type");

    free_package_list(vuln_packages);
    free_dependency_tree(dependencies);
    return 1;
}

int test_check_vulnerabilities_multiple_versions_same_package() {
    // Create vulnerable packages list with multiple versions
    PackageList *vuln_packages = create_package_list();
    TEST_ASSERT(vuln_packages != NULL, "Should create package list");

    // Add vulnerable package with multiple versions
    Package vuln_pkg = {0};
    strcpy(vuln_pkg.name, "express");
    strcpy(vuln_pkg.versions[0], "4.15.0");
    strcpy(vuln_pkg.versions[1], "4.16.0");
    vuln_pkg.version_count = 2;
    add_package(vuln_packages, &vuln_pkg);

    // Create dependencies tree
    DependencyTree *dependencies = create_dependency_tree();
    TEST_ASSERT(dependencies != NULL, "Should create dependency tree");

    // Add dependency that matches one of the vulnerable versions
    DependencyNode dep_node = {0};
    strcpy(dep_node.name, "express");
    strcpy(dep_node.version, "4.15.0");
    strcpy(dep_node.path, "direct");
    dep_node.is_direct = 1;
    add_dependency(dependencies, &dep_node);

    // Run vulnerability check
    VulnerabilityResults results = {0};
    int success = check_vulnerabilities(vuln_packages, dependencies, &results);

    TEST_ASSERT_EQ(1, success, "Should successfully check vulnerabilities");
    TEST_ASSERT_EQ(1, results.count, "Should find 1 vulnerability");

    free_package_list(vuln_packages);
    free_dependency_tree(dependencies);
    return 1;
}

int test_check_vulnerabilities_null_inputs() {
    VulnerabilityResults results = {0};

    // Test with NULL vulnerable packages
    PackageList *vuln_packages = create_package_list();
    DependencyTree *dependencies = create_dependency_tree();

    int result1 = check_vulnerabilities(NULL, dependencies, &results);
    TEST_ASSERT_EQ(0, result1, "Should return 0 for NULL vulnerable packages");

    // Test with NULL dependencies
    int result2 = check_vulnerabilities(vuln_packages, NULL, &results);
    TEST_ASSERT_EQ(0, result2, "Should return 0 for NULL dependencies");

    // Test with NULL results
    int result3 = check_vulnerabilities(vuln_packages, dependencies, NULL);
    TEST_ASSERT_EQ(0, result3, "Should return 0 for NULL results");

    free_package_list(vuln_packages);
    free_dependency_tree(dependencies);
    return 1;
}

int test_check_vulnerabilities_empty_lists() {
    // Create empty lists
    PackageList *vuln_packages = create_package_list();
    TEST_ASSERT(vuln_packages != NULL, "Should create package list");

    DependencyTree *dependencies = create_dependency_tree();
    TEST_ASSERT(dependencies != NULL, "Should create dependency tree");

    // Run vulnerability check on empty lists
    VulnerabilityResults results = {0};
    int success = check_vulnerabilities(vuln_packages, dependencies, &results);

    TEST_ASSERT_EQ(1, success, "Should successfully check empty lists");
    TEST_ASSERT_EQ(0, results.count, "Should find 0 vulnerabilities");

    free_package_list(vuln_packages);
    free_dependency_tree(dependencies);
    return 1;
}

int test_check_vulnerabilities_case_sensitivity() {
    // Create vulnerable packages list
    PackageList *vuln_packages = create_package_list();
    TEST_ASSERT(vuln_packages != NULL, "Should create package list");

    // Add vulnerable package in lowercase
    Package vuln_pkg = {0};
    strcpy(vuln_pkg.name, "lodash");
    strcpy(vuln_pkg.versions[0], "4.17.19");
    vuln_pkg.version_count = 1;
    add_package(vuln_packages, &vuln_pkg);

    // Create dependencies tree
    DependencyTree *dependencies = create_dependency_tree();
    TEST_ASSERT(dependencies != NULL, "Should create dependency tree");

    // Add dependency with mixed case - should still match since package names should be case-sensitive
    DependencyNode dep_node = {0};
    strcpy(dep_node.name, "Lodash");  // Different case
    strcpy(dep_node.version, "4.17.19");
    strcpy(dep_node.path, "direct");
    dep_node.is_direct = 1;
    add_dependency(dependencies, &dep_node);

    // Run vulnerability check
    VulnerabilityResults results = {0};
    int success = check_vulnerabilities(vuln_packages, dependencies, &results);

    TEST_ASSERT_EQ(1, success, "Should successfully check vulnerabilities");
    TEST_ASSERT_EQ(0, results.count, "Should find 0 vulnerabilities due to case mismatch");
    // But should find partial match as warning due to case-insensitive partial matching
    TEST_ASSERT_EQ(1, results.warning_count, "Should find 1 warning for partial match");

    // Verify warning details
    VulnerabilityMatch *warning = &results.warnings[0];
    TEST_ASSERT_STR_EQ("Lodash", warning->package_name, "Warning package name should match dependency");
    TEST_ASSERT_STR_EQ("lodash", warning->vulnerable_package_name, "Warning vulnerable package name should match");
    TEST_ASSERT_EQ(1, warning->match_type, "Should be partial match type");

    free_package_list(vuln_packages);
    free_dependency_tree(dependencies);
    return 1;
}

int test_check_vulnerabilities_partial_matches() {
    // Create vulnerable packages list
    PackageList *vuln_packages = create_package_list();
    TEST_ASSERT(vuln_packages != NULL, "Should create package list");

    // Add vulnerable package
    Package vuln_pkg = {0};
    strcpy(vuln_pkg.name, "@babel/core");
    strcpy(vuln_pkg.versions[0], "7.0.0");
    vuln_pkg.version_count = 1;
    add_package(vuln_packages, &vuln_pkg);

    // Create dependencies tree
    DependencyTree *dependencies = create_dependency_tree();
    TEST_ASSERT(dependencies != NULL, "Should create dependency tree");

    // Add dependency that should partially match (contains core)
    DependencyNode dep_node = {0};
    strcpy(dep_node.name, "babel-core");
    strcpy(dep_node.version, "6.26.3");
    strcpy(dep_node.path, "node_modules/babel-core");
    dep_node.is_direct = 0;
    add_dependency(dependencies, &dep_node);

    // Run vulnerability check
    VulnerabilityResults results = {0};
    int success = check_vulnerabilities(vuln_packages, dependencies, &results);

    TEST_ASSERT_EQ(1, success, "Should successfully check vulnerabilities");
    TEST_ASSERT_EQ(0, results.count, "Should find 0 exact vulnerabilities");
    TEST_ASSERT_EQ(1, results.warning_count, "Should find 1 warning for partial match");

    // Verify warning details
    VulnerabilityMatch *warning = &results.warnings[0];
    TEST_ASSERT_STR_EQ("babel-core", warning->package_name, "Warning package name should match dependency");
    TEST_ASSERT_STR_EQ("@babel/core", warning->vulnerable_package_name, "Warning vulnerable package name should match");
    TEST_ASSERT_STR_EQ("6.26.3", warning->used_version, "Used version should match dependency");
    TEST_ASSERT_STR_EQ("6.26.3", warning->vulnerable_version, "Vulnerable version should match dependency");
    TEST_ASSERT_STR_EQ("node_modules/babel-core", warning->dependency_path, "Dependency path should match");
    TEST_ASSERT_EQ(0, warning->is_direct_dependency, "Should be marked as indirect dependency");
    TEST_ASSERT_EQ(1, warning->match_type, "Should be partial match type");

    free_package_list(vuln_packages);
    free_dependency_tree(dependencies);
    return 1;
}

int test_check_vulnerabilities_multiple_matches() {
    // Test with multiple vulnerabilities and warnings
    PackageList *vuln_packages = create_package_list();
    TEST_ASSERT(vuln_packages != NULL, "Should create package list");

    // Add multiple vulnerable packages
    Package vuln_pkg1 = {0};
    strcpy(vuln_pkg1.name, "lodash");
    strcpy(vuln_pkg1.versions[0], "4.17.19");
    strcpy(vuln_pkg1.versions[1], "4.17.20");
    vuln_pkg1.version_count = 2;
    add_package(vuln_packages, &vuln_pkg1);

    Package vuln_pkg2 = {0};
    strcpy(vuln_pkg2.name, "express");
    strcpy(vuln_pkg2.versions[0], "4.15.0");
    vuln_pkg2.version_count = 1;
    add_package(vuln_packages, &vuln_pkg2);

    // Create dependencies tree
    DependencyTree *dependencies = create_dependency_tree();
    TEST_ASSERT(dependencies != NULL, "Should create dependency tree");

    // Add exact match
    DependencyNode dep1 = {0};
    strcpy(dep1.name, "lodash");
    strcpy(dep1.version, "4.17.19");
    strcpy(dep1.path, "node_modules/lodash");
    dep1.is_direct = 1;
    add_dependency(dependencies, &dep1);

    // Add another exact match
    DependencyNode dep2 = {0};
    strcpy(dep2.name, "express");
    strcpy(dep2.version, "4.15.0");
    strcpy(dep2.path, "node_modules/express");
    dep2.is_direct = 1;
    add_dependency(dependencies, &dep2);

    // Add safe version (no match)
    DependencyNode dep3 = {0};
    strcpy(dep3.name, "lodash");
    strcpy(dep3.version, "4.17.21");
    strcpy(dep3.path, "node_modules/other-lodash");
    dep3.is_direct = 0;
    add_dependency(dependencies, &dep3);

    // Run vulnerability check
    VulnerabilityResults results = {0};
    int success = check_vulnerabilities(vuln_packages, dependencies, &results);

    TEST_ASSERT_EQ(1, success, "Should successfully check vulnerabilities");
    TEST_ASSERT_EQ(2, results.count, "Should find 2 vulnerabilities");
    TEST_ASSERT_EQ(0, results.warning_count, "Should find 0 warnings");

    free_package_list(vuln_packages);
    free_dependency_tree(dependencies);
    return 1;
}

void run_vulnerability_checker_tests() {
    printf("\n=== Vulnerability Checker Unit Tests ===\n");

    RUN_TEST(test_is_version_vulnerable_match);
    RUN_TEST(test_is_version_vulnerable_no_match);
    RUN_TEST(test_is_version_vulnerable_null_inputs);

    RUN_TEST(test_check_vulnerabilities_no_matches);
    RUN_TEST(test_check_vulnerabilities_with_matches);
    RUN_TEST(test_check_vulnerabilities_multiple_versions_same_package);
    RUN_TEST(test_check_vulnerabilities_null_inputs);
    RUN_TEST(test_check_vulnerabilities_empty_lists);
    RUN_TEST(test_check_vulnerabilities_case_sensitivity);
    RUN_TEST(test_check_vulnerabilities_partial_matches);
    RUN_TEST(test_check_vulnerabilities_multiple_matches);
}